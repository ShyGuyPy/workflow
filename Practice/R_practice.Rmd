---
title: "R practice"
author: "Luke Vawter"
date: "September 18, 2018"
output: html_document
---

factors in R:
https://swcarpentry.github.io/r-novice-inflammation/12-supp-factors/
not char or string,
they are integers and behave as such
```{r}
library(magrittr)

fruits <- factor(c("grape", "bananna", "grape", "bananna", "apple", "orange"))
#sets order of factor levels
fruits <- factor(fruits, levels = c("orange", "grape", "bananna", "apple"), ordered = TRUE)
levels(fruits)
nlevels(fruits)

fruits %>%
  trimws() %>%
  print()

```

trimws():
```{r}
library(magrittr)

thing <- " this is a test   "
print(trimws(thing))
#and again using pipes
thing %>% 
  trimws() %>%
  print()

```
playing with select, filter,     :
```{r}
library(magrittr)
library(readxl)
library(dplyr)


#creates project.dir, phyto directory object 
project.dir <- rprojroot::find_rstudio_root_file()

toy.df <- read_excel(file.path(project.dir, "data/jackie_data/Data 2013_4plus-phyto-metrics.xlsx"),
                         sheet = "DATA_4+biometrics",
                         skip = 1)

#colnames(toy.df)

new.toy.df <- toy.df %>%
  #include only those columns starting with s
  select(starts_with("s")) %>%
  
  #only include rows which fall within given ranges
  filter(SURVEY_ID <= 30867, SALINITY < 6) %>%
  #select(SURVEY_ID:SAMPLE_DATE) %>
  
  #arrange in descending order based on SURVEY_ID value
  arrange(desc(SURVEY_ID)) %>%
  print()

mutant.toy.df <- toy.df %>%
  
  mutate(nonsense=SECCHI/SALINITY) %>%
  print()
  
#also could do group_by()
```

```{r}
library(magrittr)

project.dir <- rprojroot::find_rstudio_root_file()

toy.df <- read_excel(file.path(project.dir, "data/jackie_data/Data 2013_4plus-phyto-metrics.xlsx"),
                         sheet = "DATA_4+biometrics",
                         skip = 1)

toy.df %>%
  select(PIBI_Rank) %>%
  print()


```

http://r4ds.had.co.nz/data-visualisation.html
working through "R for Data Science", a resource Zach linked.  Plenty of it I'm familiar with, but I'm finding my data scientist skills could use some work so I'm doing some review:
```{r}
library(ggplot2)
library(magrittr)
# cars.df <- ggplot2::mpg
# print(cars.df)

cars.columns.df <- ggplot2::mpg %>%
  colnames() %>%
  print()

ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, color = class, shape = drv))

ggplot(data = mpg) +
  geom_point(mapping = aes(x = cyl, y = hwy, color = class, shape = drv))




```
using str_replace_all func:
```{r}
library(ggplot2)
library(magrittr)

spaces <-c("hi here", "I'm tired","need a break")
snakes <- spaces %>%
  str_replace_all(" ", "_") %>%
  print()
```

show number of rows and coumns:
```{r}
nrow(mpg)
ncol(mpg)
```

how to apply an aesthetic to the whole plot
```{r}
library(ggplot2)

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")

```

facets can be used to break the above scaterplot into separate visualizations.  In this case the data is divided by the class of the car. What we end up with is clusters of data because car class(class) and engine size(displ) are tightly related.Also, we can see distinct sections of the downward trend of the data as engine size increases, hgihtlighting the negative relationship between engine size and highway miles per gallon(hwy).:
```{r}
library(ggplot2)


ggplot(data = mpg)+
  geom_point(mapping = aes(x=displ, y = hwy))+
  facet_wrap(~class, nrow = 2)

```


adding more than one geom:
```{r}
library(ggplot2)

ggplot(data = mpg)+
  geom_smooth(mapping = aes(x=displ, y= hwy,linetype=drv, color=drv))+
  geom_point(mapping = aes(x=displ, y= hwy, color=drv))
```

gloabl geom plotting:
```{r}
ggplot(data=mpg, mapping = aes(x=displ,y=hwy))+
  geom_line(color="blue")+
  geom_point(mapping =aes(color = class))+
  geom_smooth()
  
```

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
  geom_point() + 
  geom_smooth(se=FALSE)
```

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy))+
  geom_point(mapping=aes(color=drv))+
  geom_smooth(mapping=aes(linetype=drv),se=FALSE)+
  coord_flip()
```

summary I don't fully get or see the value of but here it is:
```{r}
library(ggplot2)
ggplot(data= mpg)+
  stat_summary(
    mapping = aes(x = displ, y = hwy),
    fun.ymin = min,
    fun.ymax = max,
    fun.y = median
  )
```


position values of identity, dodge, and fill(below) alter the presentation of the data:
```{r}
ggplot(data = diamonds, mapping = aes(x=cut, fill = clarity))+
  geom_bar(alpha = 3/5, position= "fill" )
```

The use of jitter in a scatterplot fixes the problem of overplotting cuased by rounding of values.  Here we can see the clustering various points(such as position 4.7, 5 or 2.8,20).  The desnity of the blob gies us a sense of how many points land at approximately the same axis point
```{r}
ggplot(data=mpg)+
  geom_point(mapping=aes(x=displ,y=hwy), position ="jitter")
```

coxcomb chart:
```{r}
library(ggplot2)

assigned <- ggplot(data=mpg, mapping = aes(x=drv, fill =drv))+
  geom_bar(width=1)+
  theme(aspect.ratio = 1)+
  labs(x = NULL, y =NULL)


assigned + coord_polar() #+ coord_flip()
  
```

"The grammar of graphics is based on the insight that you can uniquely describe any plot as a combination of a dataset, a geom, a set of mappings, a stat, a position adjustment, a coordinate system, and a faceting scheme."


```{r}
graph_components <- c("dataset", "geom", "set of mappings", "a stat", "postion", "coordinate system", "faceting scheme" )


# for (component in graph_components){
#   print(component)
# }
```

some basic R,; seq() is a function that constructs a sequence between(inclusive) the two numbers passed to it:
```{r}
seq(1,25)
```

dplyr exercises and I need the practice:
```{r}
library(nycflights13)
library(tidyverse)

#wrapped in () to both print and assign to variable
(my_flight_data <- flights %>%
  #only showing rows where dep_delay value is greater than 20
  filter(dep_delay < -20) %>%
  #only showing columns cep_delay and arr_time
  select(dep_delay,arr_time))
  #something else
  
  
```

dealing with NA values.  is.na() can be used to reference such values:
```{r}
things.df <- tibble(stuff = c(NA,2,NA))

things.df %>%
  filter(is.na(things.df) | things.df<3)

```

playing with for loops:
```{r}
library(tidyverse)
library(dplyr)
date <- "1/1/1"

id_df <- c(1,2,3)
date_df <- c("1/1/1","2/2/2","3/3/3")
value_df <- c(12,18,10)
data.df <- data.frame(id_df,date_df, value_df)
print(data.df)

for (i in 2:nrow(data.df)){
  case_when(
    date_df[i] != "1/1/1" ~ print(paste0("nope ", value_df[i])),
    date_df[i] == "1/1/1" ~ print(paste0("yep ", value_df[i]))#"yep")
  )
}

  
             
             
```
I think the above code has an issue with how I constructed the dataframe.  Will revisit but it's not my primary issue atm.

```{r}
library(readxl)

path_p <- "C:\\Users\\icprbadmin\\Documents\\R\\2018drex\\input\\ts\\state\\i_a1b\\va_shenandoah_p.csv"
my_data_p = read.csv(path_p)

#print(my_data_p)
#print(nrow(my_data_p))
for(i in my_data_p$date){
  
  #print(i)
  if(as.character(i) == "1998-10-04"){print(my_data_p$p_percent_normal[which(my_data_p$date == i)])}#print(my_data_p$p_percent_normal[4])}
 
    
  

   #print(my_data_p[[i]])
}
```

convert date format:
```{r}
#convert from "10/1/1998" to "1998/10/01"
#date <- "10/1/1998"
date <- "5/5/1981"
month="-"
day="-"
#day_single="-0"
year =""

#iterates over string date
for(i in strsplit(date,"")[[1]]){ 
  #for single digit month values
  if (i == "/" && nchar(month) <3){month <- paste0(substring(month, 1, 1), 0, substring(month,2,2))}
  #adds value to month until month has enough characters
  if (i != "/" && nchar(month) < 3) {month <- paste0(month,i)}


  
  #adds value to day until day is long enough
  else if (i != "/" && nchar(day) <3) {day <- paste0(day,i)}
  #adds a 0 in front of day value if day is only one digit
  else if (i == "/" && nchar(month) ==3 && nchar(day) >1 && nchar(day) <3) {day <- paste0(substring(day, 1, 1), 0, substring(day,2,2))}#day <- paste0(day_single,day[2])}
  #adds value to years until it is long enough
  else if (i != "/" && nchar(day) ==3 && nchar(month) == 3 && nchar(year)<4){year<- paste0(year,i)}
  
  #else if (i == "/"){}
  # case_when(
  #   i != "/"~print("no tilde"),
  #   i == "1"~print("bingo")
#date2 <- paste0(year,month,day)
#)
}
date2 <- paste0(year,month,day)
print(date2)
```
and it works. now to add it to shiny_test_app2
...and realize I've written it to convert in reverse...
so the other way now:


```{r}
#convert from "1998-10-01" to "10/1/1998"
date <- "1990-05-17"
#date <- paste0(date,"-")
month=""
day="/"
day_single= FALSE
month_single=FALSE
year ="/"

#iterates over string date
for(i in strsplit(date,"")[[1]]){
  
  if (i != "-" && nchar(year) < 5){year<- paste0(year,i)}
  
  else if (i == "0" && nchar(month) <1){month_single = TRUE}
  else if (i != "-" && nchar(month) <1){month <- paste0(month,i)}
  else if (i != "-" && nchar(month) <2 && month_single == FALSE){month <- paste0(month,i)}
  
  else if (i == "0" && nchar(day) <2) {day_single = TRUE}
  else if (i != "-" && nchar(day) <2) {day <- paste0(day,i)}
  else if (i != "-" && nchar(day) <3 && day_single == FALSE) {day <- paste0(day,i)}

}
date2 <- paste0(month,day, year)
print(date2)
```

bug checking:
```{r}
library(readxl)
library(dplyr)


#grabs data
path_p <- "C:\\Users\\icprbadmin\\Documents\\R\\2018drex\\input\\ts\\state\\i_a1b\\va_shenandoah_p.csv"
my_data_p = read.csv(path_p, stringsAsFactors = FALSE)

#converts date format
date_func <- function(date){
  date <- as.character(date)
  date <- paste0("",date,"")
  month=""
  day="/"
  day_single= FALSE
  month_single=FALSE
  year ="/"
  
  #iterates over string date
  for(i in strsplit(date,"")[[1]]){
    
    if (i != "-" && nchar(year) < 5){year<- paste0(year,i)}
    
    else if (i == "0" && nchar(month) <1){month_single = TRUE}
    else if (i != "-" && nchar(month) <1){month <- paste0(month,i)}
    else if (i != "-" && nchar(month) <2 && month_single == FALSE){month <- paste0(month,i)}
    
    else if (i == "0" && nchar(day) <2) {day_single = TRUE}
    else if (i != "-" && nchar(day) <2) {day <- paste0(day,i)}
    else if (i != "-" && nchar(day) <3 && day_single == FALSE) {day <- paste0(day,i)}
    
  }
  date <- paste0(month,day, year)
  return(date)
}

test_date = 1998-10-04
print(date_func(test_date))

p_data_percent <-
for(i in my_data_p$date){

                    case_when(
                   as.character(i) == as.character( date_func(1998-10-04))
                      ~"good"#my_data_p$p_percent_normal[which(my_data_p$date == i)]
                    )
  
}

print(p_data_percent)
print(my_data_p$p_percent_normal[which(my_data_p$date == "1998-10-04")])

# for(i in my_data_p$date){
#   
#   #print(i)
#   if(as.character(i) == "1998-10-04"){print(my_data_p$p_percent_normal[which(my_data_p$date == i)])}#print(my_data_p$p_percent_normal[4])}
```


```{r}
library(readxl)
library(dplyr)


#grabs data
path_p <- "C:\\Users\\icprbadmin\\Documents\\R\\2018drex\\input\\ts\\state\\i_a1b\\va_shenandoah_p.csv"
my_data_p = read.csv(path_p)

# for(i in my_data_p$p_percent_normal){
#   print(typeof(i))
# }

# for(i in my_data_p$date){
#   print(typeof(i))
# }
```

```{r}
thing0 <- 1-2-3 
thing <- as.character(1-2-3)
thing2 <- "1-2-3"
thing3 <- as.double(1-2-3)

print(nchar(thing))
print(nchar(thing2))
print(thing)
print(thing0)
print(thing3)

```

R is running date values with "-" as math operations

Interesting...but discontinuing because a different approach is needed for integration into 2018DEX.

r for Data Science 5.3, 5.4:
```{r}
library(dplyr)

path_p <- "C:\\Users\\icprbadmin\\Documents\\R\\2018drex\\input\\ts\\state\\i_a1b\\va_shenandoah_p.csv"
                if( .Platform$OS.type == "unix" ) {
                  path_p <- "/Users/lukevawter/Desktop/R/2018drex/input/ts/state/i_a1b/va_shenandoah_p.csv"
                }
my_data_p = data.table::fread(path_p)
print(my_data_p)


mdp_trimmed <- my_data_p %>%
  #arrange(my_data_p$p_percent_normal) %>%
  select(-date) %>%
  select(-V3,-V4)

  
mdp_trimmed %>%
  transmute(double = my_data_p$p_percent_normal * 2) %>%
  mutate(triple = my_data_p$p_percent_normal * 3)

  


```


```{r}
library(nycflights13)

flights_sml <- select(flights,
                      year:day,
                      ends_with("delay"),
                      distance,
                      air_time
                      )

flights_mut <- flights_sml %>%
  mutate(gain = dep_delay - arr_delay,
       speed = distance / air_time * 60)

flights_mut %>%
  select(gain, speed)
```

R for Data Science 5.5:
```{r}
library(nycflights13)

flights %>%
  transmute(dep_time, hour = dep_time %/% 100,
            minutes = dep_time %% 100)
```

and a bit of python review just because I feel like I'm getting rusty:
```{python}
test_var = 517 

remains_2= test_var % 100
remains_1= (test_var - remains_2) / 100
print("{}:{}".format(remains_1,remains_2))
```


